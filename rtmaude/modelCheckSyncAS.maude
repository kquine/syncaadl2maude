load analyze-sync-active-standby.maude 


(tomod MODEL-CHECK-SYNC-AS is
  including MainActiveStandbySystemimplInstance .

  op side_active : Nat -> Formula .
  eq side 1 active 
   = value of side1ActiveSide in component (MAIN -> sideOne -> sideProcess -> sideThread) is 1 .
  eq side 2 active 
   = value of side2ActiveSide in component (MAIN -> sideTwo -> sideProcess -> sideThread) is 2 .

  op agreeOnActiveSide : -> Formula .
  eq agreeOnActiveSide =
      ((value of side1ActiveSide in component (MAIN -> sideOne -> sideProcess -> sideThread) is 1)
       /\
       (value of side2ActiveSide in component (MAIN -> sideTwo -> sideProcess -> sideThread) is 1))
     \/
      ((value of side1ActiveSide in component (MAIN -> sideOne -> sideProcess -> sideThread) is 2)
       /\
       (value of side2ActiveSide in component (MAIN -> sideTwo -> sideProcess -> sideThread) is 2)) .

  --- Notice that we do have the previous value sent anymore. Furthermore, the way our rule
  --- is defiend for synchrnous steps means that output from the environment is not 
  --- present in any state, only as input in the desitnaition ports. 

  --- Since we do not store the previous FA message, we have to do as suggested in PALS
  --- tech rep: we can only talk about the next states ...

  ops side1FullyAvailable side2FullyAvailable : -> Formula .
  eq side1FullyAvailable =
       value of side1FullyAvail in component (MAIN -> sideOne -> sideProcess -> sideThread) is true .
  eq side2FullyAvailable =
       value of side2FullyAvail in component (MAIN -> sideTwo -> sideProcess -> sideThread) is true .

  op noChangeAvailability : -> Formula .
  eq noChangeAvailability =
        (side1FullyAvailable <-> O side1FullyAvailable)
     /\ (side2FullyAvailable <-> O side2FullyAvailable) .

  op manSelectPressed : -> Formula .
  eq manSelectPressed = 
        value of manualSelection in component (MAIN -> sideOne -> sideProcess -> sideThread) is true .

  ops side1Failed side2Failed : -> Formula .
  eq side1Failed =
        value of side1Failed in component (MAIN -> sideOne -> sideProcess -> sideThread) is true .
  eq side2Failed =
        value of side2Failed in component (MAIN -> sideTwo -> sideProcess -> sideThread) is true .

  op neitherSideFailed : -> Formula .
  eq neitherSideFailed = (~ side1Failed) /\ (~ side2Failed) .

  op noChangeAssumptionNextState : -> Formula .
  eq noChangeAssumptionNextState = 
        noChangeAvailability /\ (O ~ manSelectPressed) /\ (O neitherSideFailed) .

  op R1 : -> Formula .
  eq R1 = [] (noChangeAssumptionNextState
             -> O (agreeOnActiveSide
                   \/ O (neitherSideFailed -> agreeOnActiveSide))) .
 

  op R2a : -> Formula .
  eq R2a 
   = [] ((noChangeAssumptionNextState /\ O side1FullyAvailable /\ O ~ side2FullyAvailable)
          -> O (~ side 2 active \/ (noChangeAssumptionNextState -> O ~ side 2 active))) . 
     
  op R2b : -> Formula .
  eq R2b 
   = [] ((noChangeAssumptionNextState /\ O side2FullyAvailable /\ O ~ side1FullyAvailable)
         -> O (~ side 1 active \/
              (noChangeAssumptionNextState -> O (~ side 1 active \/
                 (noChangeAssumptionNextState -> O (~ side 1 active \/
                    (noChangeAssumptionNextState -> O (~ side 1 active \/
                       (noChangeAssumptionNextState -> O (~ side 1 active)))))))))) .

  op R3g : -> Formula .
  eq R3g 
   = [] (  (~ manSelectPressed /\ agreeOnActiveSide
            /\ side1FullyAvailable /\ side2FullyAvailable
            /\ noChangeAssumptionNextState)
        ->  (  (side 1 active
                -> O O ( (manSelectPressed /\ side1FullyAvailable
                          /\ side2FullyAvailable)
                         -> side 2 active))
            /\ (side 2 active
                -> O O (  (manSelectPressed /\ side1FullyAvailable
                           /\ side2FullyAvailable)
                          -> side 1 active)))) . 

  op R4 : -> Formula .
  eq R4 
   = [] (((side1Failed /\ ~ side2Failed)
          -> O (~ side2Failed -> side 2 active))
        /\  ((side2Failed /\ ~ side1Failed)
             -> O (~ side1Failed -> side 1 active))) . 

  op R5side1 : -> Formula .
  eq R5side1 
   = [] (((side 1 active /\ side1FullyAvailable /\ ~ manSelectPressed)
          -> (side 1 active W (~ side1FullyAvailable \/ manSelectPressed))) 
         /\
         ((side 1 active /\ ~ side1FullyAvailable /\ ~ side2FullyAvailable
           /\ ~ manSelectPressed /\ ~ side1Failed)
          -> (side 1 active W
               (side2FullyAvailable \/ manSelectPressed \/ side1Failed)))) .

  op s2inStateSide2Active : -> Formula .
  eq s2inStateSide2Active = 
       (MAIN -> sideTwo -> sideProcess -> sideThread) @ side2ActiveState .

  op R5side2X : -> Formula .
  eq R5side2X 
   = []  (((s2inStateSide2Active /\ side2FullyAvailable
            /\ ~ manSelectPressed /\ ~ side1Failed)
           -> (s2inStateSide2Active W
                (~ side2FullyAvailable \/ manSelectPressed \/ side1Failed)))
        /\
          ((s2inStateSide2Active /\ ~ side1FullyAvailable /\ ~ manSelectPressed
           /\ ~ side2Failed /\ ~ side1Failed)
          -> (s2inStateSide2Active 
                W (side1FullyAvailable \/ manSelectPressed \/ side2Failed \/ side1Failed)))
        /\ 
          ((s2inStateSide2Active /\ ~ manSelectPressed /\ ~ side2Failed /\ side1Failed)
          -> (side 2 active W (manSelectPressed \/ side2Failed \/ ~ side1Failed)))) .


endtom)

set verbose on .

(mc  {initial} |=u O R1 .)
--- true in 28 seconds, the first O is needed because of the preinit-initialization thing

(mc  {initial} |=u O R2a .)
--- true in 28 seconds on my Mac!

(mc  {initial} |=u O R2b .)
--- true in 28 seconds on my Mac

(mc  {initial} |=u R3g .)
--- true in 28 seconds on my Mac air

(mc  {initial} |=u R4 .)
--- true in 27 seconds on my Mac air

(mc  {initial} |=u R5side1 .)
--- true in 27 seconds

(mc  {initial} |=u R5side2X .)
--- true in 27 seconds on my Mac air

